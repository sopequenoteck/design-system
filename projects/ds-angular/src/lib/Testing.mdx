import { Meta } from '@storybook/blocks';

<Meta title="Guides/Testing" />

# Testing — Guide des tests du Design System

Ce guide documente les stratégies et conventions de tests utilisées dans le design system Angular. Il couvre les tests unitaires, d'intégration, end-to-end et visuels.

---

## 1. Vue d'ensemble

### 1.1 Pyramide des tests

```
          ╱╲
         ╱  ╲
        ╱ E2E╲          10% — Tests Playwright (52+ tests)
       ╱──────╲
      ╱ Visual ╲        15% — Tests Chromatic (snapshots)
     ╱──────────╲
    ╱Integration ╲      25% — Tests composants (host components)
   ╱──────────────╲
  ╱   Unit Tests   ╲    50% — Tests unitaires (Jasmine/Karma)
 ╱──────────────────╲
```

### 1.2 Métriques actuelles

| Métrique | Valeur | Objectif |
|----------|--------|----------|
| Tests unitaires | 1300+ | 100% passants |
| Couverture Statements | 92%+ | ≥80% |
| Couverture Branches | 83%+ | ≥80% |
| Tests E2E | 52+ | 100 à terme |
| Visual snapshots | 80+ | En place |

---

## 2. Tests unitaires (Jasmine/Karma)

### 2.1 Configuration

```typescript
// karma.conf.js (extrait)
module.exports = function (config) {
  config.set({
    basePath: '',
    frameworks: ['jasmine', '@angular-devkit/build-angular'],
    plugins: [
      require('karma-jasmine'),
      require('karma-chrome-launcher'),
      require('karma-coverage'),
    ],
    coverageReporter: {
      dir: require('path').join(__dirname, './coverage'),
      subdir: '.',
      reporters: [
        { type: 'html' },
        { type: 'lcov' },
        { type: 'text-summary' }
      ],
      check: {
        global: {
          statements: 80,
          branches: 80,
          functions: 80,
          lines: 80
        }
      }
    },
    browsers: ['ChromeHeadless'],
    singleRun: true
  });
};
```

### 2.2 Commandes

```bash
# Tests interactifs (watch mode)
ng test ds-angular

# Tests headless (CI)
npm run test:headless

# Tests avec couverture
npm run test:coverage

# Tests d'un seul fichier
npm run test:headless -- --include=**/ds-button.spec.ts
```

### 2.3 Structure des tests

```typescript
// Exemple complet : ds-button.spec.ts
import { ComponentFixture, TestBed, fakeAsync, tick } from '@angular/core/testing';
import { Component, DebugElement } from '@angular/core';
import { By } from '@angular/platform-browser';
import { DsButton } from './ds-button';

// 1. Composant hôte pour tester les @Input/@Output
@Component({
  template: `
    <ds-button
      [variant]="variant"
      [size]="size"
      [disabled]="disabled"
      [loading]="loading"
      (clicked)="onClick()">
      {{ label }}
    </ds-button>
  `,
  standalone: true,
  imports: [DsButton],
})
class TestHostComponent {
  variant = 'primary';
  size = 'md';
  disabled = false;
  loading = false;
  label = 'Test Button';
  clickCount = 0;

  onClick(): void {
    this.clickCount++;
  }
}

describe('DsButton', () => {
  let fixture: ComponentFixture<TestHostComponent>;
  let component: TestHostComponent;
  let buttonDebugElement: DebugElement;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [TestHostComponent],
    }).compileComponents();

    fixture = TestBed.createComponent(TestHostComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
    buttonDebugElement = fixture.debugElement.query(By.css('button'));
  });

  // 2. Tests de rendu
  describe('rendering', () => {
    it('should create', () => {
      expect(component).toBeTruthy();
    });

    it('should render button element', () => {
      expect(buttonDebugElement).toBeTruthy();
    });

    it('should display label', () => {
      expect(buttonDebugElement.nativeElement.textContent).toContain('Test Button');
    });
  });

  // 3. Tests des variantes
  describe('variants', () => {
    it('should apply primary class by default', () => {
      expect(buttonDebugElement.nativeElement.classList).toContain('ds-button--primary');
    });

    it('should apply secondary class', () => {
      component.variant = 'secondary';
      fixture.detectChanges();
      expect(buttonDebugElement.nativeElement.classList).toContain('ds-button--secondary');
    });
  });

  // 4. Tests des événements
  describe('events', () => {
    it('should emit click event', () => {
      buttonDebugElement.nativeElement.click();
      expect(component.clickCount).toBe(1);
    });

    it('should not emit when disabled', () => {
      component.disabled = true;
      fixture.detectChanges();
      buttonDebugElement.nativeElement.click();
      expect(component.clickCount).toBe(0);
    });
  });

  // 5. Tests asynchrones
  describe('async behavior', () => {
    it('should handle loading state', fakeAsync(() => {
      component.loading = true;
      fixture.detectChanges();
      tick();

      expect(buttonDebugElement.nativeElement.classList).toContain('ds-button--loading');
    }));
  });

  // 6. Tests d'accessibilité
  describe('accessibility', () => {
    it('should have button role by default', () => {
      expect(buttonDebugElement.nativeElement.getAttribute('type')).toBe('button');
    });

    it('should set aria-disabled when disabled', () => {
      component.disabled = true;
      fixture.detectChanges();
      expect(buttonDebugElement.nativeElement.getAttribute('aria-disabled')).toBe('true');
    });
  });
});
```

### 2.4 Patterns de test courants

#### Tester les signals Angular

```typescript
// Avec model() - utiliser setInput dans les tests
it('should update signal value', () => {
  const componentInstance = fixture.debugElement.query(By.directive(DsToggle)).componentInstance;

  // Pour un input signal
  fixture.componentRef.setInputValue('checked', true);
  fixture.detectChanges();

  expect(componentInstance.checked()).toBe(true);
});
```

#### Tester ControlValueAccessor

```typescript
@Component({
  template: `<ds-input-field [formControl]="control"></ds-input-field>`,
  standalone: true,
  imports: [DsInputField, ReactiveFormsModule],
})
class TestFormComponent {
  control = new FormControl('');
}

describe('DsInputField CVA', () => {
  it('should update FormControl on input', fakeAsync(() => {
    const input = fixture.debugElement.query(By.css('input'));
    input.nativeElement.value = 'test';
    input.nativeElement.dispatchEvent(new Event('input'));
    tick();

    expect(component.control.value).toBe('test');
  }));

  it('should update input when FormControl changes', fakeAsync(() => {
    component.control.setValue('programmatic');
    tick();
    fixture.detectChanges();

    const input = fixture.debugElement.query(By.css('input'));
    expect(input.nativeElement.value).toBe('programmatic');
  }));
});
```

#### Tester les overlays CDK

```typescript
import { OverlayContainer } from '@angular/cdk/overlay';

describe('DsModal', () => {
  let overlayContainer: OverlayContainer;
  let overlayContainerElement: HTMLElement;

  beforeEach(() => {
    overlayContainer = TestBed.inject(OverlayContainer);
    overlayContainerElement = overlayContainer.getContainerElement();
  });

  afterEach(() => {
    overlayContainer.ngOnDestroy();
  });

  it('should open modal in overlay', fakeAsync(() => {
    component.isOpen = true;
    fixture.detectChanges();
    tick();

    const modal = overlayContainerElement.querySelector('.ds-modal');
    expect(modal).toBeTruthy();
  }));
});
```

#### Tester la navigation clavier

```typescript
it('should navigate with arrow keys', fakeAsync(() => {
  const tabs = fixture.debugElement.query(By.css('.ds-tabs'));

  const keyEvent = new KeyboardEvent('keydown', {
    key: 'ArrowRight',
    bubbles: true,
  });
  tabs.nativeElement.dispatchEvent(keyEvent);
  tick();
  fixture.detectChanges();

  expect(component.activeIndex).toBe(1);
}));
```

---

## 3. Tests d'intégration

### 3.1 Tests multi-composants

```typescript
@Component({
  template: `
    <ds-modal [isOpen]="isOpen" (closed)="isOpen = false">
      <ds-modal-header>
        <h2>Formulaire</h2>
      </ds-modal-header>
      <ds-modal-content>
        <ds-input-field
          label="Email"
          [formControl]="emailControl">
        </ds-input-field>
      </ds-modal-content>
      <ds-modal-footer>
        <ds-button (clicked)="submit()">Envoyer</ds-button>
      </ds-modal-footer>
    </ds-modal>
  `,
  standalone: true,
  imports: [DsModalComponent, DsInputField, DsButton, ReactiveFormsModule],
})
class IntegrationTestComponent {
  isOpen = true;
  emailControl = new FormControl('');
  submitted = false;

  submit(): void {
    this.submitted = true;
    this.isOpen = false;
  }
}

describe('Modal + Form Integration', () => {
  it('should submit form and close modal', fakeAsync(() => {
    // Ouvrir modal
    fixture.detectChanges();
    tick();

    // Remplir formulaire
    const input = overlayContainerElement.querySelector('input')!;
    input.value = 'test@example.com';
    input.dispatchEvent(new Event('input'));
    tick();

    // Soumettre
    const submitBtn = overlayContainerElement.querySelector('ds-button button')!;
    (submitBtn as HTMLButtonElement).click();
    tick();
    fixture.detectChanges();

    expect(component.submitted).toBe(true);
    expect(component.isOpen).toBe(false);
  }));
});
```

---

## 4. Tests E2E (Playwright)

### 4.1 Configuration

```typescript
// playwright.config.ts
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './e2e',
  timeout: 30000,
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'html',
  use: {
    baseURL: 'http://localhost:6006',
    trace: 'on-first-retry',
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
  ],
  webServer: {
    command: 'npm run storybook -- --ci',
    url: 'http://localhost:6006',
    reuseExistingServer: !process.env.CI,
  },
});
```

### 4.2 Commandes

```bash
# Lancer les tests E2E
npm run test:e2e

# Mode UI interactif
npm run test:e2e:ui

# Tests d'un fichier
npx playwright test e2e/modal.spec.ts

# Générer un rapport
npx playwright show-report
```

### 4.3 Exemple de test E2E

```typescript
// e2e/modal.spec.ts
import { test, expect } from '@playwright/test';

test.describe('DsModal', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/iframe.html?id=components-dsmodal--default');
  });

  test('should open and close modal', async ({ page }) => {
    // Ouvrir
    await page.click('button:has-text("Ouvrir")');
    await expect(page.locator('.ds-modal')).toBeVisible();

    // Fermer avec ESC
    await page.keyboard.press('Escape');
    await expect(page.locator('.ds-modal')).not.toBeVisible();
  });

  test('should trap focus within modal', async ({ page }) => {
    await page.click('button:has-text("Ouvrir")');

    // Tab à travers les éléments
    await page.keyboard.press('Tab');
    await page.keyboard.press('Tab');
    await page.keyboard.press('Tab');

    // Vérifier que le focus reste dans la modal
    const focusedElement = await page.evaluate(() => document.activeElement?.className);
    expect(focusedElement).toContain('ds-modal');
  });

  test('should be accessible', async ({ page }) => {
    await page.click('button:has-text("Ouvrir")');

    const modal = page.locator('.ds-modal');
    await expect(modal).toHaveAttribute('role', 'dialog');
    await expect(modal).toHaveAttribute('aria-modal', 'true');
  });
});
```

### 4.4 Tests de navigation clavier E2E

```typescript
// e2e/tabs.spec.ts
test.describe('DsTabs keyboard navigation', () => {
  test('should navigate with arrow keys', async ({ page }) => {
    await page.goto('/iframe.html?id=components-dstabs--default');

    // Focus sur le premier tab
    await page.click('[role="tab"]:first-child');

    // Navigation droite
    await page.keyboard.press('ArrowRight');
    await expect(page.locator('[role="tab"]:nth-child(2)')).toBeFocused();

    // Navigation gauche
    await page.keyboard.press('ArrowLeft');
    await expect(page.locator('[role="tab"]:first-child')).toBeFocused();

    // Home
    await page.keyboard.press('End');
    await expect(page.locator('[role="tab"]:last-child')).toBeFocused();
  });
});
```

---

## 5. Tests visuels (Chromatic)

### 5.1 Configuration

```json
// .chromatic.json
{
  "projectToken": "YOUR_PROJECT_TOKEN",
  "buildScriptName": "build-storybook",
  "storybookBuildDir": "storybook-static",
  "exitOnceUploaded": true
}
```

### 5.2 Commandes

```bash
# Lancer les tests visuels
npm run test:visual

# Avec baseline
npx chromatic --project-token=xxx

# Mode interactif
npx chromatic --interactive
```

### 5.3 Stories pour tests visuels

```typescript
// ds-button.stories.ts
export const AllVariants: Story = {
  parameters: {
    chromatic: { viewports: [320, 768, 1200] },
  },
  render: () => ({
    template: `
      <div style="display: flex; flex-direction: column; gap: 16px;">
        <ds-button variant="primary">Primary</ds-button>
        <ds-button variant="secondary">Secondary</ds-button>
        <ds-button variant="danger">Danger</ds-button>
        <ds-button variant="ghost">Ghost</ds-button>
        <ds-button [disabled]="true">Disabled</ds-button>
        <ds-button [loading]="true">Loading</ds-button>
      </div>
    `,
  }),
};

// États de hover/focus pour Chromatic
export const InteractionStates: Story = {
  parameters: {
    pseudo: { hover: true, focus: true },
  },
  render: () => ({
    template: `<ds-button variant="primary">Hover/Focus State</ds-button>`,
  }),
};
```

---

## 6. Tests d'accessibilité

### 6.1 Avec Storybook

```typescript
// Dans les stories
export const AccessibilityTest: Story = {
  parameters: {
    a11y: {
      config: {
        rules: [
          { id: 'color-contrast', enabled: true },
          { id: 'keyboard-navigation', enabled: true },
        ],
      },
    },
  },
};
```

### 6.2 Tests automatisés

```typescript
// a11y.spec.ts
import { test, expect } from '@playwright/test';
import AxeBuilder from '@axe-core/playwright';

test.describe('Accessibility', () => {
  test('button should have no violations', async ({ page }) => {
    await page.goto('/iframe.html?id=components-dsbutton--default');

    const accessibilityScanResults = await new AxeBuilder({ page })
      .include('.ds-button')
      .analyze();

    expect(accessibilityScanResults.violations).toEqual([]);
  });
});
```

---

## 7. Mocking et fixtures

### 7.1 Services

```typescript
// Mock du ToastService
const mockToastService = {
  show: jasmine.createSpy('show'),
  dismiss: jasmine.createSpy('dismiss'),
};

beforeEach(() => {
  TestBed.configureTestingModule({
    providers: [
      { provide: DsToastService, useValue: mockToastService },
    ],
  });
});

it('should show toast on success', () => {
  component.save();
  expect(mockToastService.show).toHaveBeenCalledWith({
    type: 'success',
    message: 'Enregistré',
  });
});
```

### 7.2 HTTP

```typescript
import { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';

describe('with HTTP', () => {
  let httpMock: HttpTestingController;

  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule],
    });
    httpMock = TestBed.inject(HttpTestingController);
  });

  it('should load data', () => {
    component.loadData();

    const req = httpMock.expectOne('/api/data');
    req.flush({ items: [1, 2, 3] });

    expect(component.items.length).toBe(3);
  });
});
```

---

## 8. CI/CD Integration

### 8.1 Workflow GitHub Actions

```yaml
# .github/workflows/ci.yml
name: CI

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run unit tests
        run: npm run test:headless

      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage/lcov.info

  e2e:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install Playwright
        run: npx playwright install --with-deps

      - name: Run E2E tests
        run: npm run test:e2e

      - name: Upload report
        uses: actions/upload-artifact@v3
        with:
          name: playwright-report
          path: playwright-report/

  visual:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Chromatic
        uses: chromaui/action@v1
        with:
          projectToken: ${{ secrets.CHROMATIC_TOKEN }}
```

---

## 9. Bonnes pratiques

### 9.1 Conventions de nommage

```typescript
describe('ComponentName', () => {
  describe('feature/section', () => {
    it('should [expected behavior] when [condition]', () => {
      // Arrange
      // Act
      // Assert
    });
  });
});
```

### 9.2 Anti-patterns à éviter

```typescript
// ❌ Test trop couplé à l'implémentation
it('should call private method', () => {
  spyOn(component, '_privateMethod');
  component.doSomething();
  expect(component._privateMethod).toHaveBeenCalled();
});

// ✅ Tester le comportement observable
it('should update UI when action performed', () => {
  component.doSomething();
  fixture.detectChanges();
  expect(fixture.debugElement.query(By.css('.result'))).toBeTruthy();
});
```

### 9.3 Isolation des tests

```typescript
// Chaque test doit être indépendant
beforeEach(() => {
  // Reset state
  fixture = TestBed.createComponent(TestComponent);
  component = fixture.componentInstance;
  fixture.detectChanges();
});

afterEach(() => {
  // Cleanup
  fixture.destroy();
});
```

---

## 10. Debugging

### 10.1 Outils

```bash
# Mode debug avec sourcemaps
ng test ds-angular --source-map

# Avec breakpoints dans Chrome DevTools
ng test ds-angular --browsers=Chrome
```

### 10.2 Techniques

```typescript
// Afficher le DOM
console.log(fixture.debugElement.nativeElement.innerHTML);

// Inspecter les éléments
const buttons = fixture.debugElement.queryAll(By.css('button'));
buttons.forEach(btn => console.log(btn.nativeElement.textContent));

// Vérifier les styles computed
const element = fixture.debugElement.query(By.css('.my-class'));
const styles = getComputedStyle(element.nativeElement);
console.log(styles.backgroundColor);
```
